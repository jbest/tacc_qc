"""Derivative File and URL Fixer

This script takes the input CSV file generated by tacc_check.py and generates
any missing derivative (medium or thumnail format) images and generates a URL
mapping file suitable for upload to Symbiota.

This script has no relevant use outside of the context of a TORCH/BRIT
image processing workflow on TACC due to the very specific directory arrangement
and configuration parameters.

"""

import csv
import argparse
from pathlib import Path
from PIL import Image
import os.path
from urllib.parse import urljoin

# Image Configuration
MED_DESIGNATOR = '_med'
THUMB_DESIGNATOR = '_thumb'
MED_SIZE = (900, 900)  # Medium image dimensions
THUMB_SIZE = (390, 390)  # Thumbnail dimensions
QUALITY = 85  # JPEG quality (1-100)

# For URL generation
FILE_BASE_PATH = '/corral-repl/projects/TORCH/web/'
URL_BASE = 'https://web.corral.tacc.utexas.edu/torch/'

ap = argparse.ArgumentParser()
ap.add_argument("-i", "--input", required=True, \
    help="Path to the input file generated by tacc_check.py.")
ap.add_argument("-n", "--dry_run", action="store_true", \
    help="No files generated, print report of how many files exsit, how many would be created.")

args = vars(ap.parse_args())
input_file = args['input']
dry_run = args['dry_run']

existing_web_image_count = 0
missing_web_image_count = 0
existing_med_image_count = 0
missing_med_image_count = 0
existing_thumb_image_count = 0
missing_thumb_image_count = 0
incomplete_record_count = 0

def create_derivative(web_image_path=None, derivative_designator=None):
    """Will generate new derivative if needed."""
    if web_image_path.exists():
        # Create derivative name
        derivative_file_name = full_image_path.stem + derivative_designator + full_image_path.suffix
        # Check if derivative image currently exists
        derivative_file_path = full_image_path.parent.joinpath(derivative_file_name)
        if derivative_file_path.exists():
            # Derivative was generated between time directory was scanned and now
            print('Derivative exists:', derivative_file_path)
            return derivative_file_path # Existing path
        else:
            # Generate derivative
            derivative_result = generate_derivative(
                source_path=web_image_path,
                derivative_path=derivative_file_path,
                derivative_designator=derivative_designator)
            return derivative_result
    else:
        print('Full image missing:', web_image_path)
        return None


def generate_derivative(
        source_path=None,
        derivative_path=None,
        derivative_designator=None,
        maintain_aspect=True):
    """Generate derivative files based on designation."""
    if derivative_designator == THUMB_DESIGNATOR:
        dimension = THUMB_SIZE
    if derivative_designator == MED_DESIGNATOR:
        dimension = MED_SIZE
    if dry_run:
        return derivative_path
    else:

        try:
            with Image.open(source_path) as img:
                if maintain_aspect:
                    # Use thumbnail method to maintain aspect ratio
                    img.thumbnail(dimension, Image.Resampling.LANCZOS)
                else:
                    # Resize to exact dimensions (may distort image)
                    img = img.resize(dimension, Image.Resampling.LANCZOS)
                
                # Convert to RGB if necessary (handles RGBA, P mode images)
                if img.mode in ('RGBA', 'P'):
                    img = img.convert('RGB')
                
                # Save the resized image
                img.save(derivative_path, 'JPEG', quality=QUALITY, optimize=True)
                return derivative_path
                
        except Exception as e:
            print(f"Error processing {source_path}: {str(e)}")
            return None


def generate_url(file_base_path=FILE_BASE_PATH, file_path=None, url_base=URL_BASE):
    """Generate a URL using the file paths and URL base path."""
    if file_path:
        common_path = os.path.commonpath([file_base_path, file_path])
        relative_path = os.path.relpath(file_path, start=common_path)
        image_url = urljoin(URL_BASE, relative_path)
        return image_url
    else:
        return None

# Generate new derivative files
# Logging new images in format for Symbiota URL mapping ingest
occurrence_set = {}
with open(input_file) as csvfile:
    reader = csv.DictReader(csvfile)
    for row in reader:
        if not row['web_jpg_thumb_path'] or not row['web_jpg_med_path']:
            if row['web_jpg_path']:  # Must have a large web image to create derivs
                existing_web_image_count += 1
                catalog_number = row['catalog_number']
                full_image_path = Path(row['web_jpg_path'])
                # TODO only log new urls
                if catalog_number not in occurrence_set:
                    print('adding:', catalog_number)
                    occurrence_set[catalog_number] = {'catalog_number': catalog_number}
                    occurrence_set[catalog_number]['large'] = generate_url(file_path=row['web_jpg_path'])
                # TODO: log new, complete records
                if not row['web_jpg_thumb_path']:                    
                    missing_thumb_image_count += 1
                    print('missing thumb record:', row['web_jpg_path'])
                    # Create thumb derivative if needed
                    derivative_path = create_derivative(
                        web_image_path=full_image_path,
                        derivative_designator=THUMB_DESIGNATOR)
                    occurrence_set[catalog_number]['thumbnail'] = generate_url(file_path=derivative_path)
                else:
                    #occurrence_set[catalog_number]['thumbnail'] = row['web_jpg_thumb_path']
                    existing_thumb_image_count += 1
                    occurrence_set[catalog_number]['thumbnail'] = generate_url(file_path=row['web_jpg_thumb_path'])
                if not row['web_jpg_med_path']:
                    missing_med_image_count += 1
                    print('missing med record:', row['web_jpg_path'])
                    derivative_path = create_derivative(
                        web_image_path=full_image_path,
                        derivative_designator=MED_DESIGNATOR)
                    occurrence_set[catalog_number]['web'] = generate_url(
                        file_path=derivative_path)
                else:
                    #occurrence_set[catalog_number]['web'] = row['web_jpg_med_path']
                    existing_med_image_count += 1
                    occurrence_set[catalog_number]['web'] = generate_url(file_path=row['web_jpg_med_path'])
                # if either deriv path is empty, remove URLs, not a complete set
                if not occurrence_set[catalog_number]['thumbnail'] and not occurrence_set[catalog_number]['web']:
                    incomplete_record_count += 1
                    del occurrence_set[catalog_number]
            else:
                # Full image file not present
                missing_web_image_count += 1

# Write complete URL records in Symbiota URL mapping format
if dry_run:
    output_file_name = Path(input_file).stem + '_DRY-RUN_new_urls.csv'
else:
    output_file_name = Path(input_file).stem + '_new_urls.csv'

with open(output_file_name, 'w', newline='') as csvfile:
    fieldnames = ['catalog_number', 'large', 'web', 'thumbnail']
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
    writer.writeheader()
    for key, image_set in occurrence_set.items():
        writer.writerow(image_set)
print('URL mapping file written to:', output_file_name)

# Print report
print('existing_web_image_count:', existing_web_image_count)
print('missing_web_image_count:', missing_web_image_count)
print('existing_med_image_count:', existing_med_image_count)
print('missing_med_image_count:', missing_med_image_count)
print('existing_thumb_image_count:', existing_thumb_image_count)
print('missing_thumb_image_count:', missing_thumb_image_count)
print('incomplete_record_count:', incomplete_record_count)
